1. ApeX Omni API and Python SDK
Authentication & Key Management: ApeX Omni uses a dual-signature scheme (API key + ZK proof). You must generate API credentials (key, secret, passphrase) from the ApeX Omni web portal, and also obtain ZK-proof materials (seeds and l2Key). The official ApeX Python SDK (apexomni on PyPI) streamlines this by providing methods to derive and store l2Key and seeds from an Ethereum walletgithub.comapi-docs.pro.apex.exchange. Typically, you supply your API key credentials and ZK seeds when initializing the SDK’s client. For example:
from apexomni.http_private_v3 import HttpPrivateSign
from apexomni.constants import APEX_OMNI_HTTP_TEST, NETWORKID_OMNI_TEST_BNB

client = HttpPrivateSign(
    APEX_OMNI_HTTP_TEST,
    network_id=NETWORKID_OMNI_TEST_BNB,
    zk_seeds="your_seed",
    zk_l2Key="your_l2Key",  # '' if not available, SDK can derive it
    api_key_credentials={'key': API_KEY, 'secret': API_SECRET, 'passphrase': PASSPHRASE}
)
This sets up a signed session for private REST callsgithub.comgithub.com. The SDK can also derive ZK keys via client.derive_zk_key(eth_address) if you provide an Ethereum private key (this yields a seeds and l2Key)api-docs.pro.apex.exchange. Best practice is to store API secrets and ZK seeds securely (e.g. in environment variables or encrypted config) and never commit them to code. The SDK will persist keys if configured, but you should still handle them as sensitive secrets.
SDK Installation & Docs: Install the SDK with pip install apexomni. The GitHub repo provides README and examplesgithub.comgithub.com. Official API documentation is available on the ApeX Omni API Docs sitegithub.com, including an FAQ and “Best Practice” guideapi-docs.pro.apex.exchange. It’s recommended to start with the Testnet (use APEX_OMNI_HTTP_TEST and the test network ID) to avoid risks, switching to mainnet endpoints when ready.
API Endpoints via SDK: The apexomni SDK exposes high-level methods for both public and private endpoints:
•	Account & Balance: client.get_account_v3() returns account info including balances and open positionsapi-docs.pro.apex.exchangeapi-docs.pro.apex.exchange. This is the main call to get equity and margin details. You can also fetch isolated pieces: e.g. client.account_balance_v3() or similar if provided (the docs list “GET Account balance” separatelyapi-docs.pro.apex.exchange). The account data includes total equity, margin usage, and lists of openPositions with fields like symbol, side, size, entry price, unrealized P&L, etc.api-docs.pro.apex.exchange.
•	Market Data and Instruments: Use HttpPublic for public data (no auth needed). For example, client = HttpPublic(APEX_OMNI_HTTP_TEST) then client.configs_v3() yields the list of tradable instruments and their specificationsgithub.com. From configs_v3 you can extract each symbol’s contract type, min/max order size, price tick size, quantity step, leverage limits, and whether the market is active (tradable). This is crucial for validating order parameters. Other public endpoints include client.depth_v3(symbol), client.trades_v3(symbol) for order book and recent trades, and historical klines via client.klines_v3(symbol="ETHUSDT", interval=5, ...)github.com.
•	Submitting Orders: The primary method is client.create_order_v3(...). It supports market, limit, stop, and take-profit orders, with parameters for size, price, side, type, timeInForce, etc. Notably, even market orders require a price on ApeX (used as a worst-case execution bound for ZK signature)api-docs.pro.apex.exchange. You can obtain a suitable market price via GET /v3/get-worst-price or using top-of-book plus some slippageapi-docs.pro.apex.exchange. Example SDK usage:
•	createOrderRes = client.create_order_v3(symbol="BTC-USDT", side="SELL", type="MARKET", 
•	                                       size="0.001", price="60000", timestampSeconds=time.time())
This would place a 0.001 BTC sell at market with 60,000 as the worst-case priceapi-docs.pro.apex.exchange. For stop-loss or take-profit orders, the SDK provides flags: isOpenTpslOrder=True and then isSetOpenSl=True with slPrice, slTriggerPrice, etc., to attach a stop-loss, and similarly isSetOpenTp=True with tpPrice for take-profitapi-docs.pro.apex.exchangeapi-docs.pro.apex.exchange. The triggerPrice field is used for stop-market or stop-limit orders (the price at which the order triggers)api-docs.pro.apex.exchange. All orders require a unique clientOrderId – the SDK will generate one if not provided, or you can use your own UUIDapi-docs.pro.apex.exchange. It’s recommended to always use a unique ID per order for trackingapi-docs.pro.apex.exchange.
•	Order Management: You can cancel orders by ID or clientOrderId using client.cancel_order_v3(orderId=...) or the equivalent. There’s also client.delete_open_orders_v3(symbol="BTC-USDT") to mass-cancel all open orders for given symbolsapi-docs.pro.apex.exchange. Modifying an order (changing price/size) typically requires cancel-and-replace; ApeX doesn’t allow in-place edit of an existing order due to the need for a new signature. Instead, you would cancel and submit a new order (the SDK doesn’t have a single “amend” call).
•	Querying Orders & Fills: client.open_orders_v3(symbol="ETH-USDT") returns currently open ordersapi-docs.pro.apex.exchange. There are also endpoints for order history and trade fills (e.g. client.fills_v3(...) or similar) to retrieve recent executions. The docs list “GET All Order History” and “GET Fills” endpoints for comprehensive historyapi-docs.pro.apex.exchange. Use these to display fill reports or P&L calculations.
•	Positions: Open positions are already given by get_account_v3 as mentioned. There may also be a dedicated client.position_v3(symbol) call (some APIs have such, but if not, the account call suffices). Each position includes size, side (LONG/SHORT or BUY/SELL), entry value, unrealized P&L, and margin info.
•	WebSockets – Real-time Updates: The SDK’s WebSocket class allows subscribing to real-time feedsgithub.comgithub.com. After connecting to APEX_OMNI_WS_TEST or _WS_MAIN and authenticating (with the same API key credentials), you can subscribe to private topics to get live updates on orders, trades, and positions. The primary private channel is "ws_zk_accounts_v3", which pushes incremental updates whenever your orders or positions changeapi-docs.pro.apex.exchangeapi-docs.pro.apex.exchange. For example, ws_client = WebSocket(endpoint=APEX_OMNI_WS_TEST, api_key_credentials={...}); ws_client.account_info_stream_v3(handle_message) will subscribe you to account updatesgithub.comgithub.com. Each push message contains only the fields that changed (e.g. an "orders" array when an order status updates, a "positions" entry when a position size changes, etc.)api-docs.pro.apex.exchange. This is ideal for updating the UI in real-time with fills and P&L. You should subscribe to this before placing ordersapi-docs.pro.apex.exchange. Public channels (no auth) are available for market data: e.g. ws_client.depth_stream(callback, 'BTCUSDT', 25) for order book depth, ticker_stream for live ticker, trade_stream for live tradesgithub.com. The SDK’s demo_ws_v3.py demonstrates these subscriptions.
Best Practices:
•	Use Testnet for Development: Always begin on the test network (ApeX provides a test endpoint and network ID for Binance Chain testnet, as shown above)github.com. This prevents accidental real trades and lets you simulate scenarios. Ensure the code can easily switch between testnet and mainnet (e.g. via config flags).
•	Rate Limits & Error Handling: ApeX rate limits are fairly high (e.g. ~600 GET requests per minute, 300 POST/min as of a 2025 review) and 200 orders per user per minute for order creationapi-docs.pro.apex.exchange. Still, implement prudent limits and exponential backoff on errors. The SDK will raise exceptions or return error codes – check for these and handle gracefully (retry if transient network error, but not on logical errors like “insufficient balance”). The use of clientOrderId helps with idempotency: if you receive no response due to a timeout but the order might have gone through, you can safely re-submit the same clientOrderId – the backend will reject it if the order already exists, preventing duplicate ordersapi-docs.pro.apex.exchangeapi-docs.pro.apex.exchange. Log such events for manual reconciliation.
•	Secure Storage: Never hardcode API secrets or private keys. Use environment variables or a secure vault. If the SDK persists the seeds and l2Key (it can cache them after first derivation), ensure the file is protected. For a production environment, consider encrypting these values and require a manual unlock at startup. Also, zero out sensitive variables in memory after use if possible.
•	Time Synchronization: The API signature uses a timestamp (APEX-TIMESTAMP header) – ensure your system clock is accurate (within a few seconds of NTP) to avoid auth errorsapi-docs.pro.apex.exchangeapi-docs.pro.apex.exchange. The SDK handles this for you, but clock drift can still cause authentication to fail.
•	Use of Nonces and Expirations: ApeX orders require an expiration timestamp (in seconds) for how long the order is valid on L2api-docs.pro.apex.exchangeapi-docs.pro.apex.exchange. The docs recommend 28 days by defaultapi-docs.pro.apex.exchange. The SDK example uses timestampSeconds=time.time() and likely auto-calculates expiration internally if not given. Ensure your orders have a reasonable expiry and handle the case where an expired order is rejected. Also, the nonce (used in user registration and some payloads) should be managed by SDK, but if you manually use any low-level call, remember each L2 order needs a unique nonce.
•	WebSocket Usage: It’s recommended to authenticate and subscribe to the order/position channel before placing ordersapi-docs.pro.apex.exchange. This way you catch the immediate PENDING → OPEN → FILLED status flow via WS events rather than polling REST. Implement heartbeats or ping/pong on the WS (ApeX may require periodic ping). The SDK likely handles pings, but if not, you may need to send them to keep the connection aliveapi-docs.pro.apex.exchange. Reconnect logic should resubscribe to channels and re-authenticate if the socket drops.
•	Use ClientOrderId for Idempotency: As noted, generate a unique client ID for each order (e.g. a UUID4). The API only demands uniqueness among open orders, but it’s wise to never reuse an ID even after an order closesapi-docs.pro.apex.exchange. Store the client IDs with your order records so you can track and match WS updates.
•	Error handling: Plan for cases like “order rejected” (e.g. order book moved and your market order’s price was not sufficiently aggressive – ApeX might cancel it as could_not_fillapi-docs.pro.apex.exchange). Handle INSUFFICIENT_BALANCE, BELOW_MIN_SIZE, etc., by catching the error message and informing the user immediately. The SDK likely returns error info in the response JSON under a code or msg field – check those.
•	Test Edge Cases on Testnet: e.g. submitting an order below minimum size, or extremely large size, invalid price ticks, etc., to see how errors are returned. This will help you build robust validation.

